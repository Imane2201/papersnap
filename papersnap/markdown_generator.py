"""
Markdown Generator module for PaperSnap
Creates clean, structured markdown output from paper summaries
"""

import logging
from typing import Dict, Any, List
from datetime import datetime

logger = logging.getLogger(__name__)

class MarkdownGenerator:
    """Generator for creating clean markdown summaries"""
    
    def __init__(self):
        self.template = self._load_template()
    
    def generate_markdown(self, summary_data: Dict[str, Any], metadata: Dict[str, Any]) -> str:
        """Generate markdown output from summary data"""
        try:
            logger.info("Generating markdown output")
            
            # Extract data
            title = summary_data.get("title", "Unknown Title")
            authors = summary_data.get("authors", [])
            abstract = summary_data.get("abstract", "")
            key_contributions = summary_data.get("key_contributions", [])
            methodology = summary_data.get("methodology", "")
            results = summary_data.get("results", "")
            limitations = summary_data.get("limitations", "")
            future_work = summary_data.get("future_work", "")
            overall_summary = summary_data.get("overall_summary", "")
            technical_details = summary_data.get("technical_details", {})
            
            # Format authors
            authors_str = self._format_authors(authors)
            
            # Format contributions
            contributions_str = self._format_list_items(key_contributions)
            
            # Generate citation
            citation = self._generate_citation(metadata)
            
            # Format technical details
            technical_str = self._format_technical_details(technical_details)
            
            # Build markdown content
            markdown_content = f"""# {title}

## Authors
{authors_str}

## Abstract
{abstract}

## Key Contributions
{contributions_str}

## Methodology
{methodology}

## Results
{results}

## Limitations
{limitations}

## Future Work
{future_work}

## Overall Summary
{overall_summary}

## Technical Details
{technical_str}

## Citation
{citation}

## Paper Information
{self._format_paper_info(metadata)}

---
*Summary generated by PaperSnap on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
            
            logger.info("Markdown generation completed")
            return markdown_content
            
        except Exception as e:
            logger.error(f"Error generating markdown: {e}")
            raise Exception(f"Failed to generate markdown: {e}")
    
    def generate_html(self, summary_data: Dict[str, Any], metadata: Dict[str, Any]) -> str:
        """Generate HTML output from summary data"""
        try:
            logger.info("Generating HTML output")
            
            # First generate markdown
            markdown_content = self.generate_markdown(summary_data, metadata)
            
            # Convert to HTML (basic conversion)
            html_content = self._markdown_to_html(markdown_content)
            
            # Wrap in HTML document
            html_document = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{summary_data.get('title', 'Paper Summary')}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }}
        h1 {{
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #34495e;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 5px;
        }}
        ul {{
            padding-left: 20px;
        }}
        li {{
            margin-bottom: 5px;
        }}
        .citation {{
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
        }}
        .technical-details {{
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }}
        .footer {{
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
            color: #7f8c8d;
            font-style: italic;
        }}
    </style>
</head>
<body>
    {html_content}
</body>
</html>"""
            
            logger.info("HTML generation completed")
            return html_document
            
        except Exception as e:
            logger.error(f"Error generating HTML: {e}")
            raise Exception(f"Failed to generate HTML: {e}")
    
    def _format_authors(self, authors: List[str]) -> str:
        """Format authors list"""
        if not authors:
            return "*Authors not specified*"
        
        if len(authors) == 1:
            return authors[0]
        elif len(authors) == 2:
            return f"{authors[0]} and {authors[1]}"
        else:
            return f"{', '.join(authors[:-1])}, and {authors[-1]}"
    
    def _format_list_items(self, items: List[str]) -> str:
        """Format list items as markdown"""
        if not items:
            return "*No specific contributions identified*"
        
        formatted_items = []
        for item in items:
            # Clean up the item
            item = item.strip()
            if item.startswith('â€¢') or item.startswith('-') or item.startswith('*'):
                item = item[1:].strip()
            
            formatted_items.append(f"- {item}")
        
        return '\n'.join(formatted_items)
    
    def _format_technical_details(self, technical_details: Dict[str, str]) -> str:
        """Format technical details"""
        if not technical_details:
            return "*No technical details specified*"
        
        details = []
        for key, value in technical_details.items():
            if value and value.strip() and value.strip() != "Not specified":
                details.append(f"**{key.title()}**: {value}")
        
        return '\n\n'.join(details) if details else "*No technical details specified*"
    
    def _format_paper_info(self, metadata: Dict[str, Any]) -> str:
        """Format paper information"""
        info_items = []
        
        # ArXiv information
        if metadata.get("arxiv_id"):
            info_items.append(f"**ArXiv ID**: {metadata['arxiv_id']}")
            info_items.append(f"**ArXiv URL**: {metadata.get('arxiv_url', '')}")
        
        # PDF information
        if metadata.get("pdf_path"):
            info_items.append(f"**PDF Path**: {metadata['pdf_path']}")
        
        # Publication information
        if metadata.get("journal_ref"):
            info_items.append(f"**Journal**: {metadata['journal_ref']}")
        
        if metadata.get("doi"):
            info_items.append(f"**DOI**: {metadata['doi']}")
        
        # Categories
        if metadata.get("categories"):
            categories = metadata["categories"]
            if isinstance(categories, list):
                categories_str = ", ".join(categories)
            else:
                categories_str = str(categories)
            info_items.append(f"**Categories**: {categories_str}")
        
        # Dates
        if metadata.get("published"):
            info_items.append(f"**Published**: {metadata['published']}")
        
        if metadata.get("pages"):
            info_items.append(f"**Pages**: {metadata['pages']}")
        
        return '\n\n'.join(info_items) if info_items else "*No additional paper information available*"
    
    def _generate_citation(self, metadata: Dict[str, Any]) -> str:
        """Generate APA style citation"""
        try:
            title = metadata.get("title", "Unknown Title")
            authors = metadata.get("authors", [])
            
            # Format authors for citation
            if not authors:
                authors_citation = "Unknown Author"
            elif len(authors) == 1:
                authors_citation = authors[0]
            elif len(authors) == 2:
                authors_citation = f"{authors[0]} & {authors[1]}"
            else:
                authors_citation = f"{', '.join(authors[:-1])}, & {authors[-1]}"
            
            # Get year
            year = "n.d."
            if metadata.get("published"):
                try:
                    year = metadata["published"][:4]
                except:
                    year = "n.d."
            
            # Base citation
            citation = f"{authors_citation} ({year}). *{title}*"
            
            # Add ArXiv information if available
            if metadata.get("arxiv_id"):
                citation += f". arXiv preprint arXiv:{metadata['arxiv_id']}"
            
            # Add journal information if available
            if metadata.get("journal_ref"):
                citation += f". {metadata['journal_ref']}"
            
            # Add DOI if available
            if metadata.get("doi"):
                citation += f". https://doi.org/{metadata['doi']}"
            elif metadata.get("arxiv_url"):
                citation += f". {metadata['arxiv_url']}"
            
            return citation
            
        except Exception as e:
            logger.warning(f"Error generating citation: {e}")
            return f"*Citation could not be generated for this paper*"
    
    def _markdown_to_html(self, markdown_content: str) -> str:
        """Basic markdown to HTML conversion"""
        html_content = markdown_content
        
        # Headers
        html_content = html_content.replace('# ', '<h1>').replace('\n', '</h1>\n', 1)
        html_content = html_content.replace('## ', '<h2>').replace('\n', '</h2>\n')
        
        # Bold text
        import re
        html_content = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', html_content)
        
        # Italic text
        html_content = re.sub(r'\*(.*?)\*', r'<em>\1</em>', html_content)
        
        # Lists
        lines = html_content.split('\n')
        processed_lines = []
        in_list = False
        
        for line in lines:
            if line.strip().startswith('- '):
                if not in_list:
                    processed_lines.append('<ul>')
                    in_list = True
                processed_lines.append(f'<li>{line.strip()[2:]}</li>')
            else:
                if in_list:
                    processed_lines.append('</ul>')
                    in_list = False
                processed_lines.append(line)
        
        if in_list:
            processed_lines.append('</ul>')
        
        # Paragraphs
        html_content = '\n'.join(processed_lines)
        html_content = re.sub(r'\n\n+', '</p>\n<p>', html_content)
        html_content = f'<p>{html_content}</p>'
        
        # Clean up empty paragraphs
        html_content = re.sub(r'<p>\s*</p>', '', html_content)
        
        # Add special styling for citation
        html_content = html_content.replace('## Citation', '<h2>Citation</h2><div class="citation">')
        html_content = html_content.replace('## Paper Information', '</div>\n<h2>Paper Information</h2>')
        
        return html_content
    
    def _load_template(self) -> str:
        """Load markdown template (for future customization)"""
        return """# {title}

## Authors
{authors}

## Abstract
{abstract}

## Key Contributions
{contributions}

## Methodology
{methodology}

## Results
{results}

## Limitations
{limitations}

## Future Work
{future_work}

## Overall Summary
{overall_summary}

## Technical Details
{technical_details}

## Citation
{citation}

## Paper Information
{paper_info}

---
*Summary generated by PaperSnap on {date}*
"""